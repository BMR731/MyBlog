
---
title: iOS 开发中的代码重构
date: 2016-04-05 17:29:03
tags: iOS
categories: iOS
---

代码重构<!--more-->
# Code Refactoring

## Function refactoring
- **Extract Method(提取函数)-------将大函数按模块拆分成几个小的函数**
Extract Method被翻译成中文就是提取函数的意思，这一点在代码重构中用的非常非常的多。在重构时提倡将代码模块进行细分，因为模块越小，可重用度就越大。不要写大函数，如果你的函数过大，那么这意味着你的函数需要重构了。因为函数过大，可维护性，可理解性就会变差。并且当你实现类似功能的时候就容易产生重复代码。写代码时，最忌讳的就是代码重复。这也就是经常所说的DRY（Don`t Repeat Yourself）原则。所以当函数过长时，你需要将其细分，将原函数拆分成几个函数。

- **Inline Method ---- 内联函数：将微不足道的小函数进行整合**
Inline Method其实是和Extract Method相对的。当你在重构或者平时编程时，对模块进行了过度的封装，也就是使用Extract Method有点过头了，把过于简单的东西进行了封装，比如一个简单的布尔表达式，而且该表达式只被用过一次。此时就是过度的使用Extract Method的表现了。物极必反，所以我们需要使用Inline Method进行中和，将过度封装的函数在放回去，或者将那些没有必要封装的函数放回去。也就是Extract Method相反的做法。

- **Replace Temp with Query----以查询取代临时变量: 将一些临时变量使用函数替代**
.Replace Temp with Query说白了就是将那些有着复杂表达式赋值并且多次使用的临时变量使用查询函数取代，也就是说该临时变量的值是通过函数的返回值来获取的。这样一来在实现类似功能的函数时，这些复杂的临时变量就可以进行复用，从而减少代码的重复率。取而代之的是两个查询方法，对应的查询方法返回的就是之前消除的临时变量或常量的值。
 
- **Inline Temp ---内联临时变量：与上面的Replace Temp with Query相反**
当临时变量只被一个简单的表达式赋值，而该临时变量妨碍了其他重构手法。此时我们就不应该使用Replace Temp with Query。之所以有时我们会使用到Inline Temp规则，是因为Replace Temp with Query规则使用过度造成的情况，还是物极必反，使用Replace Temp with Query过度时，就需要使用Inline Temp进行修正，当然Inline Temp的示例与Replace Temp with Query正好相反，在此就不做过多的赘述了。
- **Introduce Explaining Variable---引入解释性变量：将复杂的表达式拆分成多个变量**当一个函数中有一个比较复杂的表达式时，我们可以将表达式根据功能拆分成不同的变量。拆分后的表达式要比之前未拆分的表达式的可读性更高。将表达式拆分成相应的临时变量，也就是Introduce Explaining Variable，如果临时变量被多次使用的话，我们还可以尝试着使用Replace Temp with Query规则去除临时变量，也就是将临时变量换成查询函数。
- **Split Temporary Variable-----分解临时变量：一心不可二用**
什么叫分解临时变量的，具体说来就是在一个函数中一个临时变量不能做两种事情，也就是一个临时变量不能赋上不同意义的值。如果你这么做了，那么对不起，请对该重复使用的临时变量进行分解，也就是说你需要创建一个新的临时变量来接收第二次分配给第一个临时变量的值，并为第二个临时变量命一个确切的名字。
- **Remove Assignments to Parameters----移除对参数的赋值**
“移除对参数的赋值”是什么意思呢？顾名思义，就是在函数中不要对函数参数进行赋值。也就是说你在函数的作用域中不要对函数的参数进行赋值（当然，输入输出参数除外），当直接对函数的参数进行修改时，对不起，此时你应该对此重构。因为这样会是参数的原始值丢失，我们需要引入临时变量，然后对这个临时变量进行操作。
- **Replace Method with Method Object----以函数对象取代函数**
当一个特别长的函数，而且函数中含有比较复杂的临时变量，使用上述那些方法不好进行重构时，我们就要考虑将该函数封装成一个类了。这个对应的类的对象就是函数对象。我们可以将该场函数中的参数以及临时变量转变成类的属性，函数要做的事情作为类的方法。将函数转变成函数类后，我们就可以使用上述的某些方法对新的类中的函数进行重构了。
>[The raw article here](http://www.cnblogs.com/ludashi/p/5223241.html)

## class refactoring
- **Move Method----方法迁移**
关于Move Method，首先谈论一下为什么要进行方法的迁移。原因很简单，就是当类中的方法不适合放在当前类中时，就应该为该方法寻找合适下家。那么怎样才可以称作是当前方法不适合在当前类中呢？一个类中的函数与另一个类有很多的交互，函数非常依赖于某个类。如果一个类有太多行为，或者与另一个类有太多合作而形成高度耦合。此时就应该将该方法搬移到其高度依赖的类中。
在给方法搬家时需要做的就是在方法的新家中创建一个方法，实现要搬移的功能，如果新创建的函数需要旧类中的数据，那么就创建一个委托对象来解决这个问题。说白了就是在另一个类中创建一个相同的功能的新函数，将旧函数变成一个单纯的委托函数，或者将旧函数完全移除。搬移后，我们可以再使用函数的重构规则对新组的函数进行重构。

- **Move Field----搬移字段**
Move Field(搬移字段)与Move Method适用场景类似。当在一个类中的某一个字段，被另一个类的对象频繁使用时，我们就应该考虑将这个字段的位置进行更改了。Move Field与Move Method的思想和做法差不多，再次对其的示例就省略了。举一反三，你可以类比着Move Method来使用Move Field规则
- **Extract Class----提炼类**
Extract Class和Extract Method类似，Extract Method提取的是方法，而Extract Class提取的是类。一个类如果过于复杂，做了好多的事情，违背了“单一职责”的原则，所以需要将其可以独立的模块进行拆分，当然有可能由一个类拆分出多个类。当然，对类的细化也是为了减少代码的重复性，以及提高代码的复用性，便于代码的维护。下方将会通过一个实例，对类进行提炼
- **Inline Class----类的内联化**
又到了“物极必反”的时候了。Extract Method与Inline Method职责相反，Extract Class当然也就职责相反的原则。那就是接下来要介绍的类的内联化：Inline Class。如果过度使用Extract Class原则的话，会使得某些类过于简单并且调用该简单的类的地方极少。也就是说一个类根本不能称为一个类，所以我们可以通过Inline Class将过度抽象出来的类放到其他类中。
- **Hide Delegate----隐藏“委托关系”**
隐藏类之间的“委托关系”这一原则用起来是非常不错的，它可以简化类调用委托者的方式。简单的说就是讲委托调用的链，封装成相应的方法，使其隐藏掉具体的调用细节，从而简化了调用方式。
- **Introduce Foreign Method----引入外加函数**
这一点在开发中用的还是比较多的，有时候你在不想或者不能修改原类的情况下想为该类添加新的方法。在这种情况下就会使用到Introduce Foreign Method。在Swift语言中，使用Introduce Foreign Method原则特别简单，也就是在不改变类的情况下对类进行扩展也是特别简单的。因为Swift语言以及OC中有延展的功能，所以非常对此非常好实现的。
>[The raw article here](http://www.cnblogs.com/ludashi/p/5227486.html)

## Data refactoring
- **Self Encapsulate Field (自封装字段)**
自封装字段"理解起来比较简单，一句话概括：虽然字段对外是也隐藏的，但是还是有必要为其添加getter方法，在类的内部使用getter方法来代替self.field，该方式称为自封装字段，自己封装的字段，自己使用。当然该重构规则不是必须执行的，因为如果你直接使用self来访问类的属性如果不妨碍你做扩展或者维护，那么也是可以的，毕竟直接访问变量更为容易阅读。各有各的好处，间接访问字段的好处是使你的程序更为模块化，可以更为灵活的管理数据。比如在获取值时，因为后期需求的变化，该获取的字段需要做一些计算，那么间接访问字段的方式就很容易解决这个问题，而直接访问字段的方式就不是很好解决了。所以间接一下还是好处多多的，不过直接访问不影响你的应用程序的话，也是无伤大雅的。 
>In this case,you are better to use self encapsulated:When a value or attribute of class may changed afterwords;the class may have subclass

- **Replace data Value with Object(以对象取代数据值)**
以对象取代数据值”说白了就是我们常说的实体类，也就是Model类。Model的职责就将一些相关联的数据组织在一起来表示一个实体。Model类比较简单，一般只用于数据的存储，其中有一些相关联的字段，并为这些相关联的字段添加getter/和setter方法。

- **Change Value to Reference (将值对象改变成引用对象)**
在介绍“将值对象改变成引用对象”之前，我们先去了解一下值对象和引用对象的区别。先说一下值对象，比如两个相等的数值，存入了两个值对象中，这两个值对象在内存中分别占有两块不同的区域，所以改变其中一个值不会引起另一个值得变化。而引用对象正好相反，一个内存区域被多个引用指针所引用，这些引用指针即为引用对象，因为多个指针指向同一块内存地址，所以无论你改变哪一个指针中的值，其他引用对象的值也会跟着变化,
基于值对象和引用对象的特点，我们有时候根据程序的上下文和需求需要将一些值类型改变成引用类型。因为有时候需要一些类的一些对象在应用程序中唯一。这和单例模式又有一些区别，单例就是一个类只能生成一个对象，而“将值对象改变成引用对象”面临的就是类可以创建多个对象，但是这多个对象在程序中是唯一的，并且在某一个引用点修改对象中的属性时，其他引用点的对象值也会随之改变。
- **Change Reference to Value(将引用对象改为值对象)**
将引用对象改为值对象，该重构规则正好与上面相反。在一些情况下使用值对象更为简单，更易管理，但前提是该值对象很小并且不会被改变。在这种情况下你就没有必要使用引用对象了。从上面的示例来看，使用引用对象实现起来还是较为复杂的。还是那句话，如果你的对象非常小，而且在创建后其中的数据不会被改变，如果需要改变就必须在创建一个新的对象来替换原来的对象。在这种情况下使用值对象是完全可以的。在此就不做过多的赘述了。
不过在使用值对象时，你最好为值对象提供一个重载的相等运算符用来比较值对象中的值。也就是说只要是值对象中的每个属性的值都相同，那么这两个值对象就相等。至于如何对“==” 运算符进行重载就不做过多的赘述了，因为该知识点不是本篇博客的重点。
- **Replace Array or Dictionary with Object(以对象取代数组或字典)**
这一点呢和本篇博客的第二部分其实是一个。就是当你使用数组或者字典来组织数据，这些数据组合起来代表一定的意义，这是最好将其定义成一个实体类。还是那句话，定义成实体类后，数据更易管理， 便于后期需求的迭代。下
- **Duplicate Observed Data(复制“被监测数据”)**
这一部分是比较重要的部分，也是在做UI开发时经常遇到的部分。用大白话将就是你的业务逻辑与GUI柔和在了一起，因为UI作为数据的入口，所以在写程序时，我们就很容易将数据处理的方式与UI写在一起。这样做是非常不好的，不利于代码的维护，也不利于代码的可读性。随着需求不断的迭代，版本不断的更新，UI与业务逻辑融合的代码会变得非常难于维护。所以我们还是有必要将于UI无关的代码从UI中进行分离，将业务逻辑从GUI中进行剥离。所以在接下来的实例中是和UI实现有关的，会根据一个比较简单的Demo来一步步的将UI中的业务逻辑进行分离。进入该部分的主题。复制“被监测数据”简单的说，就是将UI提供的数据复制一份到我们的业务逻辑层，然后与UI相应的数据进行关联，UI数据变化，被复制的业务逻辑中的数据也会随之变化。这一点也就是所谓的"响应式编程"吧.
>将依赖与数据却不依赖于UI的代码提取出来，为之创建相应的业务处理类，然后将在UI里创建相应的对象，即可将UI的数据与业务处理的数据进行绑定，这应该就是ViewModal的现身
- **Change Unidirectional Association to Bidirectional(将单向关联改为双向关联)**
-  **Replace Magic Number with Synbolic Constant(以字面常量取代魔法数)**
这一点说白了就是不要在你的应用程序中直接出现字数值。这一点很好理解，在使用字面数值时，我们要使用定义好的常量来定义。因为这样更易于维护，如果同一个字面数值写的到处都是，维护起来及其困难。当使用字面常量时维护起来就容易许多。该规则比较容易理解，在此不做过多的赘述
-  **Encapsulate Field（封装字段)**
当你的类中有对外开放字段时，最好将其进行封装，不要直接使用对象来访问该字段，该优缺点与上述的“自封装字段”的优缺点类似。因为直接访问类的字段，会降低程序的模块化，不利于程序的扩充和功能的添加。再者封装是面向对象的特征之一，所以我们需要将字段变成私有的，然后对外提供相应的setter和getter方法
-  **Encapsulate Collection（封装集合)**
“封装集合”这一重构规则应该来说并不难理解。当你的类中有集合时，为了对该集合进行封装，你需要为集合创建相应的操作方法，例如增删改查等等。
- **Replace Subclass with Fields（以字段取代子类)**
什么叫“以字段取代子类”呢？就是当你的各个子类中唯一的差别只在“返回常量数据”的函数上。当遇到这种情况时，你就可以将这个返回的数据放到父类中，并在父类中创建相应的工厂方法，然后将子类删除即可。
 > [The raw article here](http://www.cnblogs.com/ludashi/p/5236024.html)
## The condition express refractor rule
- **Decompose Conditional(分解条件表达式)**
顾名思义，分解条件表达式说白了，就是当你的条件表达式比较复杂时，你就可以对其进行拆分。一般拆分的规则为：经if后的复杂条件表达式进行提取，将其封装成函数。如果if与else语句块中的内容比较复杂，那么就将其提取，也封装成独立的函数，然后在相应的地方进行替换。
- **Consolidate Conditional Expression(合并条件表达式)**
“合并条件表达式”这条规则也是比较好理解的，因为有时候会存在这样的情况，也就是一些条件表达式后的语句体执行的代码块相同。说白了也就是不同的条件有着同样的返回结果。当然一般在你程序设计之初不会出现此问题，因为在我们设计程序时，如果不同的条件返回相同的结果，我们肯定会将其合并的。不过当你在多个版本迭代，多个需求要增加，或者在别人的代码上进行需求迭代的时候，该情况是很有可能发生的。
- **Consolidate Duplicate Conditional Fragments(合并重复的条件片段)**
本部分是合并的是重复的条件片段。什么叫合并重复的条件片段呢？这种情况也是一般不会在设计程序之初所出现，但是随着时间的推移，项目不断迭代更新，或者需求变更和迭代更新等等，在项目后期维护时比较容易出现重复的条件片段。在开发中是比较忌讳重复的代码的，如果出现重复的代码，那么说明你的代码应该被重构了。   
- **Remove Control Flag(移除控制标记)**
“移除控制标记”这一点还是比较重要的，我平时在代码开发中有时候也会使用到标记变量，来标记一些事物的状态。使用标记变量最直观的感受就是不易维护，不易理解。因为在需求变更或者迭代中，你还得维护这标记变量。如果维护一个标记变量简单的话，那么维护多个标记变量就没这么容易了。而且在你的程序中使用标记变量时，不易理解，并且会显得逻辑混乱。*在平时开发中尽量的要少使用标记变量。不到万不得已，不要在你的代码中引入标记变量。如果有，尝试着去除标记变量。*
- **Replace Nested Condition with Guard Clauses(以卫语句取代嵌套的条件)**
常见的if-let嵌套应该被gurad等进行拆解语句
```
for key in keys{
	let number = D1[key]
	if number == nil{
	continue
	}
	 
	 let name = d2[number!]
	 if name != nil {
	 continue
	 }
	 ..
}
```
- **Replace Condition with Polymorphism(以多态取代条件表达式)**
多态就是类的不同类型的对象有着不同的行为状态。如果在你的条件表达式中条件是对象的类型，也就是根据对象的不同类型然后做不同的事情。在这种情况下使用多态在合适不过了。如果该部分在设计模式中，应该对应着状态模式这一部分。这就是以多态来取代条件表达式。
[The raw article here](http://www.cnblogs.com/ludashi/p/5257273.html)

